"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to HTML</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css">
    <style>
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }
    </style>
</head>
<body>
    <div class="markdown-body">
        <h3 id="schema-evolution-in-grpc-rest-and-graphql">Schema Evolution in gRPC, REST, and GraphQL</h3>
<p>Schema evolution refers to how APIs handle changes (e.g., adding, modifying, or removing fields/types) over time while maintaining backward compatibility for existing clients. gRPC uses Protocol Buffers (protobuf) for strict, wire-format compatibility; REST relies on HTTP conventions and optional specs like OpenAPI; GraphQL emphasizes additive, versionless evolution via its schema definition language (SDL). Below is a comparison of their key options, rules, and trade-offs.</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th><strong>gRPC (Protobuf)</strong></th>
<th><strong>REST</strong></th>
<th><strong>GraphQL</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Primary Mechanism</strong></td>
<td>Backward/forward compatibility rules in proto3: Changes must preserve wire format (field numbers). No explicit versioning in URLs; evolve via proto file updates.</td>
<td>Versioning strategies (URI: <code>/v2/users</code>; header: <code>Accept: application/vnd.v2+json</code>; query: <code>?version=2</code>) or evolution within versions (additive changes in OpenAPI docs).</td>
<td>Versionless evolution: Single schema evolves additively; use directives like <code>@deprecated</code> for warnings. Clients query exact fields, so additions don't break.</td>
</tr>
<tr>
<td><strong>Allowed Changes</strong></td>
<td>- <strong>Additive</strong>: Add new fields with unique numbers (optional by default).<br>- <strong>Deprecate</strong>: Mark with <code>deprecated: true</code>; clients ignore.<br>- <strong>Removal</strong>: Reserve numbers to prevent reuse; don't change existing types/numbers.</td>
<td>- <strong>Additive</strong>: New endpoints/fields in same version.<br>- <strong>Breaking</strong>: Bump version for removals/changes.<br>- Use OpenAPI for schema docs; evolve by extending without breaking contracts.</td>
<td>- <strong>Additive</strong>: Add fields/types (safe, as clients opt-in).<br>- <strong>Deprecate</strong>: <code>@deprecated(reason: &quot;Use newField&quot;)</code>.<br>- <strong>Breaking</strong>: Rare; use unions/interfaces for flexibility; avoid changing existing field types.</td>
</tr>
<tr>
<td><strong>Compatibility Rules</strong></td>
<td>Strict: Old writers/new readers (forward) and new writers/old readers (backward) must work. E.g., don't rename fields (use aliases via comments); avoid required fields in proto3.</td>
<td>Flexible but manual: Ensure non-breaking changes within a version (e.g., default values for new fields). Tools like Schema Registry check compatibility.</td>
<td>Client-driven: Queries specify fields, so additions are safe; removals need deprecation period. Schema introspection helps clients adapt.</td>
</tr>
<tr>
<td><strong>Pros</strong></td>
<td>- Enforced at compile-time via code-gen.<br>- Efficient binary format minimizes breakage risks.<br>- Supports streaming without version churn.</td>
<td>- Simple, widely adopted (e.g., HTTP standards).<br>- Explicit versions isolate changes clearly.<br>- Tools like Redocly automate doc evolution.</td>
<td>- No versioning overhead; continuous delivery.<br>- Reduces over-fetching; easy for complex, nested data.<br>- Built-in introspection for client discovery.</td>
</tr>
<tr>
<td><strong>Cons</strong></td>
<td>- Rigid rules can feel limiting (e.g., no field renumbering).<br>- Binary schemas harder to inspect manually.<br>- Service/method changes require full recompilation.</td>
<td>- Version proliferation (e.g., multiple endpoints to maintain).<br>- No built-in enforcement; relies on discipline.<br>- Can lead to &quot;version hell&quot; in large APIs.</td>
<td>- N+1 query issues if not optimized.<br>- Deprecations require client updates; breaking changes still possible in core types.<br>- Schema bloat if not governed.</td>
</tr>
<tr>
<td><strong>Best For</strong></td>
<td>Internal, high-performance services needing strict contracts (e.g., microservices at Google/Netflix).</td>
<td>Public APIs with broad compatibility (e.g., e-commerce endpoints).</td>
<td>Client-heavy apps with varying data needs (e.g., mobile dashboards at Facebook).</td>
</tr>
</tbody>
</table>
<p>In practice, combine approaches: Use gRPC internally for efficiency, REST/GraphQL externally for flexibility. Always test compatibility (e.g., protobuf's <code>protoc --decode</code> for gRPC) and document changes.</p>

    </div>
</body>
</html>"