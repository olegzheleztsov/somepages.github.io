"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to HTML</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css">
    <style>
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }
    </style>
</head>
<body>
    <div class="markdown-body">
        <h3 id="what-is-a-saga">What is a Saga?</h3>
<p>In the context of distributed systems and microservices architecture, a <strong>Saga</strong> is a design pattern for managing long-running transactions across multiple services without relying on traditional two-phase commit (2PC) protocols. Introduced by Hector Garcia-Molina and Kenneth Salems in the 1980s (originally for fault-tolerant databases), it has become a cornerstone for handling distributed workflows in modern cloud-native apps.</p>
<p>A Saga breaks down a complex transaction into a sequence of smaller, local transactions (steps), each executed by a different service. Each step includes:</p>
<ul>
<li>A <strong>forward operation</strong> (the business action, e.g., &quot;reserve inventory&quot;).</li>
<li>A <strong>compensating transaction</strong> (a rollback action, e.g., &quot;release inventory&quot; if the overall process fails).</li>
</ul>
<p>There are two main orchestration styles:</p>
<ul>
<li><strong>Orchestrator-based</strong>: A central coordinator (e.g., a Saga orchestrator service) sequences the steps and triggers compensations on failure.</li>
<li><strong>Choreography-based</strong>: Services communicate via events (e.g., Pub-Sub), and each reacts autonomously to progress or trigger compensationsâ€”no central controller.</li>
</ul>
<h4 id="what-is-it-for">What is it For?</h4>
<p>The Saga pattern addresses the challenges of <strong>distributed transactions</strong> in microservices, where services are loosely coupled and use separate databases (preventing global locks like 2PC). Its primary goals are:</p>
<ul>
<li><strong>Ensuring Consistency</strong>: Achieves &quot;eventual consistency&quot; by compensating for partial failures, avoiding the &quot;all-or-nothing&quot; rigidity of ACID transactions across boundaries.</li>
<li><strong>Fault Tolerance and Resilience</strong>: Handles failures gracefully (e.g., network issues, service crashes) without blocking the entire system.</li>
<li><strong>Scalability</strong>: Allows independent service scaling, as transactions don't require cross-service locking.</li>
<li><strong>Simplicity Over 2PC</strong>: 2PC is brittle in distributed environments (high latency, single points of failure); Sagas are more pragmatic for high-throughput systems.</li>
</ul>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Traditional 2PC</th>
<th>Saga Pattern</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Consistency Model</strong></td>
<td>Strong (immediate)</td>
<td>Eventual</td>
</tr>
<tr>
<td><strong>Failure Handling</strong></td>
<td>Global rollback (coordinator-dependent)</td>
<td>Local compensations (decentralized)</td>
</tr>
<tr>
<td><strong>Scalability</strong></td>
<td>Poor (locks span services)</td>
<td>High (async, non-blocking)</td>
</tr>
<tr>
<td><strong>Complexity</strong></td>
<td>High (coordination overhead)</td>
<td>Medium (but requires idempotent ops)</td>
</tr>
<tr>
<td><strong>Use Case Fit</strong></td>
<td>Monolithic DBs</td>
<td>Microservices/e-commerce workflows</td>
</tr>
</tbody>
</table>
<h4 id="example-in-action">Example in Action</h4>
<p>In an e-commerce order flow:</p>
<ol>
<li><strong>Step 1</strong>: Order service creates order (forward: save order; compensating: cancel order).</li>
<li><strong>Step 2</strong>: Payment service processes payment (forward: charge card; compensating: refund).</li>
<li><strong>Step 3</strong>: Inventory service reserves stock (forward: deduct qty; compensating: add back qty).</li>
<li><strong>Step 4</strong>: Shipping service schedules delivery (forward: book shipment; compensating: cancel shipment).</li>
</ol>
<p>If payment fails, the orchestrator triggers compensations in reverse order. Tools like Axon Framework, Camunda, or Netflix Conductor implement this.</p>
<p>This pattern pairs well with the Transactional Outbox for reliable event publishing during steps. For your interview, how might you implement idempotency in Saga compensations to handle retries?</p>

    </div>
</body>
</html>"