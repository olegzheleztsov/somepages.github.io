"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to HTML</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css">
    <style>
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }
    </style>
</head>
<body>
    <div class="markdown-body">
        <h3 id="kubernetes-services-overview">Kubernetes Services: Overview</h3>
<p>In Kubernetes (K8s), a <strong>Service</strong> is an abstraction that provides a stable endpoint (IP and DNS name) to expose a set of pods, enabling reliable communication between workloads or external clients. Services decouple frontends from backends by load-balancing traffic across matching pods (via labels/selectors, as we discussed earlier). Without a Service, pods get dynamic IPs that change on restart—Services fix that with a virtual IP (VIP) and optional DNS resolution.</p>
<p>Services are cluster-scoped but can be namespaced. They're defined in YAML under <code>kind: Service</code> and use <code>spec.selector</code> to target pods. Key features:</p>
<ul>
<li><strong>Load Balancing</strong>: Distributes traffic evenly (round-robin by default).</li>
<li><strong>Discovery</strong>: Internal DNS like <code>my-svc.my-namespace.svc.cluster.local</code>.</li>
<li><strong>Health Checks</strong>: Integrates with readiness/liveness probes on pods.</li>
<li><strong>Ports</strong>: Maps service ports to pod target ports (e.g., expose port 80 to pod's 8080).</li>
</ul>
<p>In a .NET context, Services are essential for exposing ASP.NET Core APIs or connecting microservices (e.g., via gRPC or HTTP).</p>
<h4 id="types-of-services">Types of Services</h4>
<p>Kubernetes offers four main types, each suited to different access patterns. The default is ClusterIP.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
<th>Key Specs</th>
<th>Networking Behavior</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ClusterIP</strong></td>
<td>Exposes the service on an internal cluster IP. Only reachable from within the cluster.</td>
<td><code>spec.type: ClusterIP</code> (default). Optional: <code>spec.clusterIP: None</code> for &quot;headless&quot; (direct pod IPs, useful for stateful discovery).</td>
<td>Internal VIP; no external access. Uses kube-proxy for routing.</td>
</tr>
<tr>
<td><strong>NodePort</strong></td>
<td>Exposes the service on each node's IP at a static port (30000–32767 range). Accessible from outside via <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>.</td>
<td><code>spec.type: NodePort</code><br><code>spec.ports[].nodePort: 30080</code> (auto or manual).</td>
<td>Opens ports on all nodes; traffic proxies to pods. Often combined with ClusterIP.</td>
</tr>
<tr>
<td><strong>LoadBalancer</strong></td>
<td>Exposes the service externally using a cloud provider's load balancer (e.g., AWS ELB, Azure LB). Provisions a public IP.</td>
<td><code>spec.type: LoadBalancer</code><br>Integrates with cloud APIs for auto-provisioning.</td>
<td>External LB IP; routes to nodes/pods. Costly in cloud; use annotations for tweaks (e.g., <code>service.beta.kubernetes.io/aws-load-balancer-type: nlb</code>).</td>
</tr>
<tr>
<td><strong>ExternalName</strong></td>
<td>Maps the service to an external DNS name (no pods selected). Acts as a CNAME record.</td>
<td><code>spec.type: ExternalName</code><br><code>spec.externalName: my.external.domain.com</code>. No selector needed.</td>
<td>No proxying; resolves to external endpoint (e.g., SaaS API). No load balancing.</td>
</tr>
</tbody>
</table>
<h4 id="use-cases">Use Cases</h4>
<p>Services shine in layered architectures—e.g., a .NET frontend pod calling a backend API via service DNS.</p>
<ul>
<li><p><strong>ClusterIP Use Cases</strong>:</p>
<ul>
<li><strong>Internal Microservices Communication</strong>: A .NET Blazor app in <code>frontend-ns</code> calls <code>backend-api-service.default.svc.cluster.local</code> for data. Ideal for east-west traffic in a monorepo .NET solution deployed to K8s.</li>
<li><strong>Headless for Stateful Apps</strong>: With <code>clusterIP: None</code>, discover individual pods in a StatefulSet (e.g., .NET app querying specific SQL Server replicas by pod hostname).</li>
<li><strong>Why?</strong> Secure and efficient—no external exposure needed. Common in 80%+ of services.</li>
</ul>
</li>
<li><p><strong>NodePort Use Cases</strong>:</p>
<ul>
<li><strong>Development/Testing Access</strong>: Expose a .NET debug API during local K8s (Minikube) testing: Access via <code>minikube ip:30080</code>. Quick for port-forward alternatives.</li>
<li><strong>On-Premises or Edge</strong>: In non-cloud setups (e.g., bare-metal .NET IoT cluster), route external traffic to nodes without a full LB.</li>
<li><strong>Why?</strong> Simple external access, but avoid in prod due to port exhaustion and security (firewall all NodePorts).</li>
</ul>
</li>
<li><p><strong>LoadBalancer Use Cases</strong>:</p>
<ul>
<li><strong>Production Web Apps</strong>: Deploy a scalable .NET e-commerce API; K8s provisions an Azure Load Balancer with a public IP. Handles SSL termination and auto-scaling.</li>
<li><strong>High-Availability Ingress</strong>: Front an Ingress controller for multiple .NET services, distributing global traffic.</li>
<li><strong>Why?</strong> Seamless cloud integration, but incurs costs (~$0.01/hr per LB). Use for public-facing .NET APIs with traffic spikes.</li>
</ul>
</li>
<li><p><strong>ExternalName Use Cases</strong>:</p>
<ul>
<li><strong>Hybrid Integrations</strong>: Point a .NET app's service to an external SaaS like <code>api.stripe.com</code> for payments—avoids hardcoding URLs in code.</li>
<li><strong>Migration Scenarios</strong>: During a lift-and-shift, alias legacy on-prem DB to <code>old-db.company.internal</code> while phasing to K8s-hosted .NET with EF Core.</li>
<li><strong>Why?</strong> DNS-based routing without K8s overhead; great for non-K8s dependencies.</li>
</ul>
</li>
</ul>
<h4 id="example-yaml-snippet">Example YAML Snippet</h4>
<p>For a ClusterIP Service exposing a .NET pod:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: dotnet-api-service
spec:
  type: ClusterIP
  selector:
    app: dotnet-api
  ports:
  - port: 80          # Service port
    targetPort: 8080  # Pod port
    protocol: TCP
</code></pre>
<h4 id="best-practices">Best Practices</h4>
<ul>
<li>Combine with Ingress for HTTP routing (e.g., path-based to .NET services).</li>
<li>Use <code>kubectl port-forward svc/my-svc 8080:80</code> for local dev access.</li>
<li>Monitor with Prometheus: Label services for metrics scraping.</li>
<li>Security: Apply NetworkPolicies to restrict service access.</li>
</ul>
<p>This covers the essentials—Services make K8s apps &quot;production-ready.&quot; Next: Ingress, Secrets, or a .NET deployment walkthrough? What's your pick?</p>

    </div>
</body>
</html>"