"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to HTML</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css">
    <style>
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }
    </style>
</head>
<body>
    <div class="markdown-body">
        <h3 id="configuring-tracing-in-istio">Configuring Tracing in Istio</h3>
<p>Distributed tracing in Istio allows you to collect and visualize trace spans for requests flowing through your mesh, helping debug latency, errors, and dependencies in microservices. Istio's Envoy proxies automatically generate spans for traffic they handle, exporting them to backends like Jaeger or Zipkin. Configuration focuses on enabling tracing, setting sampling rates (to control volume), adding custom tags, and integrating with providers.</p>
<p>As of October 2025, Istio (v1.22+) supports two approaches: the legacy <strong>MeshConfig and pod annotations</strong> (simpler for basic setups) and the modern <strong>Telemetry API</strong> (more flexible, CRD-based for per-namespace/workload scoping). Use Telemetry API for new deployments, as it deprecates legacy options. Prerequisites include:</p>
<ul>
<li>A running Istio installation on Kubernetes.</li>
<li>Applications propagating tracing headers (e.g., <code>x-request-id</code>, <code>x-b3-traceid</code> for Zipkin/Jaeger).</li>
<li>A tracing backend (e.g., Jaeger) deployed in your cluster.</li>
</ul>
<p>Below, I'll outline steps for both methods, starting with backend setup. Examples assume a Kubernetes environment with ASP.NET Core services (e.g., via <code>Grpc.Net.Client</code> for header propagation).</p>
<h4 id="step-1-set-up-a-tracing-backend-e.g.jaeger">Step 1: Set Up a Tracing Backend (e.g., Jaeger)</h4>
<p>Jaeger is a popular choice for Istio. Deploy it via Helm for simplicity.</p>
<ol>
<li>Add the Jaeger Helm repo: <code>helm repo add jaegertracing https://jaegertracing.github.io/helm-charts</code>.</li>
<li>Install Jaeger in the <code>istio-system</code> namespace:
<pre><code>helm install jaeger jaegertracing/jaeger --namespace istio-system --set provisionDataStore.cassandra=false
</code></pre>
This deploys Jaeger's all-in-one service (collector + query UI) on port 16686.</li>
<li>Expose the UI: <code>kubectl port-forward svc/jaeger-query -n istio-system 16686:16686</code>.</li>
<li>Verify: Access http://localhost:16686 to see the Jaeger UI.</li>
</ol>
<p>For other backends (Zipkin, OpenTelemetry), follow similar Helm installs and update provider configs below.</p>
<h4 id="step-2-configure-tracing-legacy-meshconfig-and-pod-annotations">Step 2: Configure Tracing (Legacy: MeshConfig and Pod Annotations)</h4>
<p>This method uses global <code>MeshConfig</code> via IstioOperator for defaults, overridable per-pod. It's quick but less granular.</p>
<ol>
<li><p><strong>Enable Tracing Globally</strong>: Create <code>tracing.yaml</code> to install/reinstall Istio with tracing enabled.</p>
<pre><code class="language-yaml">apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  meshConfig:
    enableTracing: true  # Enables tracing
    defaultConfig:
      tracing:
        sampling: 1.0  # 1% sampling (0.0-100.0)
        max_path_tag_length: 256  # Truncate long paths
        custom_tags:  # Optional: Add tags
          clusterID:
            environment:
              name: ISTIO_META_CLUSTER_ID  # From env var
</code></pre>
<p>Apply: <code>istioctl install -f tracing.yaml --skip-confirmation</code>.</p>
</li>
<li><p><strong>Customize Sampling</strong>: Adjust <code>sampling</code> for traffic volume (e.g., 100.0 for all requests in testing). Reapply the IstioOperator.</p>
</li>
<li><p><strong>Add Custom Tags</strong>: Tags enrich spans (literal, env var, or header-based). Examples in the YAML above; reapply for changes.</p>
</li>
<li><p><strong>Override Per-Workload</strong>: Annotate your Deployment (e.g., for an ASP.NET Core pod) to override globals.</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-aspnet-service
spec:
  template:
    metadata:
      annotations:
        proxy.istio.io/config: |  # YAML block for overrides
          tracing:
            sampling: 100.0  # 100% for this workload
            custom_tags:
              my_header_tag:
                header:
                  name: user-agent  # From request header
    spec:
      containers:
      - name: app
        image: my-aspnet-grpc:latest  # Your .NET image
</code></pre>
<p>Apply: <code>kubectl apply -f deployment.yaml</code>.</p>
</li>
<li><p><strong>Verify</strong>: Generate traffic (e.g., via <code>curl</code> or .NET HttpClient), then check Jaeger UI for spans.</p>
</li>
</ol>
<h4 id="step-3-configure-tracing-modern-telemetry-api">Step 3: Configure Tracing (Modern: Telemetry API)</h4>
<p>Telemetry API uses CRDs for scoped configs (mesh-wide, namespace, or workload-specific). It requires disabling legacy MeshConfig tracing.</p>
<ol>
<li><p><strong>Define Extension Provider</strong>: In <code>tracing.yaml</code>, add your backend (e.g., Jaeger) as a provider and disable legacy.</p>
<pre><code class="language-yaml">apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  meshConfig:
    enableTracing: true
    defaultConfig:
      tracing: {}  # Disable legacy MeshConfig tracing
    extensionProviders:  # Define provider
    - name: jaeger
      jaeger:
        service: jaeger-collector.istio-system.svc.cluster.local
        port: 14250  # Jaeger's gRPC port
</code></pre>
<p>Apply: <code>istioctl install -f tracing.yaml --skip-confirmation</code>.</p>
</li>
<li><p><strong>Enable Tracing</strong>: Create a <code>Telemetry</code> CRD for mesh-wide activation.</p>
<pre><code class="language-yaml">apiVersion: telemetry.istio.io/v1alpha3  # Or v1/v1alpha1
kind: Telemetry
metadata:
  name: mesh-default
  namespace: istio-system
spec:
  tracing:
  - providers:
    - name: jaeger  # Reference the provider
</code></pre>
<p>Apply: <code>kubectl apply -f telemetry.yaml</code>.</p>
</li>
<li><p><strong>Customize Sampling</strong>: Add <code>randomSamplingPercentage</code> (default 1.0) to the <code>Telemetry</code> spec.</p>
<pre><code class="language-yaml">spec:
  tracing:
  - providers:
    - name: jaeger
    randomSamplingPercentage: 100.00  # 100% sampling
</code></pre>
<p>Reapply the CRD.</p>
</li>
<li><p><strong>Add Custom Tags</strong>: Under <code>customTags</code> in the provider section (supports literal, environment, header).<br />
<strong>Literal Example</strong>:</p>
<pre><code class="language-yaml">spec:
  tracing:
  - providers:
    - name: jaeger
      randomSamplingPercentage: 100.00
      customTags:
        provider:
          literal:
            value: &quot;jaeger-provider&quot;
</code></pre>
<p><strong>Header Example</strong> (for .NET request headers):</p>
<pre><code class="language-yaml">spec:
  tracing:
  - providers:
    - name: jaeger
      customTags:
        user_agent:
          header:
            name: user-agent
            defaultValue: &quot;unknown&quot;
</code></pre>
<p>Reapply for changes.</p>
</li>
<li><p><strong>Scope to Namespace/Workload</strong>: Create <code>Telemetry</code> in a specific namespace (e.g., <code>default</code>) or label selectors for workloads.</p>
<pre><code class="language-yaml">metadata:
  name: default-tracing
  namespace: default  # Applies to this namespace
spec:
  selector:  # Optional: Target specific workloads
    matchLabels:
      app: my-aspnet-service
</code></pre>
<p>Apply per scope.</p>
</li>
<li><p><strong>Customize Path Tag Length</strong>: Set <code>maxTagLength</code> in the extension provider (IstioOperator level).</p>
<pre><code class="language-yaml">- name: jaeger
  jaeger:
    service: jaeger-collector.istio-system.svc.cluster.local
    port: 14250
    maxTagLength: 512  # Custom limit
</code></pre>
<p>Reinstall Istio.</p>
</li>
<li><p><strong>Verify</strong>: Generate traffic from your .NET app (ensure <code>services.AddOpenTelemetry()</code> propagates headers if using OTEL). View traces in Jaeger.</p>
</li>
</ol>
<h4 id="comparison-meshconfig-vs.telemetry-api">Comparison: MeshConfig vs. Telemetry API</h4>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>MeshConfig/Annotations</th>
<th>Telemetry API</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Granularity</strong></td>
<td>Global or per-pod</td>
<td>Mesh/namespace/workload via CRDs</td>
</tr>
<tr>
<td><strong>Enabling</strong></td>
<td><code>enableTracing: true</code> in IstioOperator</td>
<td>Explicit <code>Telemetry</code> CRD with providers</td>
</tr>
<tr>
<td><strong>Sampling/Tags</strong></td>
<td>Basic sampling; limited tags</td>
<td>Advanced (e.g., header-based tags)</td>
</tr>
<tr>
<td><strong>Use Case</strong></td>
<td>Quick legacy setups</td>
<td>Modern, scalable configs (recommended)</td>
</tr>
</tbody>
</table>
<h4 id="net-specific-tips">.NET-Specific Tips</h4>
<ul>
<li>In ASP.NET Core, use <code>Microsoft.Extensions.Telemetry</code> or OpenTelemetry SDK to propagate headers: <code>services.AddOpenTelemetry().WithTracing(builder =&gt; builder.AddAspNetCoreInstrumentation());</code>.</li>
<li>For gRPC services, ensure <code>Grpc.Net.Client</code> includes tracing via <code>channel.Interceptors.Add(new TracingInterceptor());</code>.</li>
<li>Test locally with Kind + Istio; monitor overhead (~1-2% CPU for sampling).</li>
</ul>
<p>For full details on other backends (e.g., OpenTelemetry export), see the sub-tasks in Istio docs. If using Ambient mode (Istio 1.20+), tracing works identically but with lower proxy overhead.</p>

    </div>
</body>
</html>"