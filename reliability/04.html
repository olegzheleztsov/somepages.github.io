"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to HTML</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css">
    <style>
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }
    </style>
</head>
<body>
    <div class="markdown-body">
        <h3 id="what-is-the-circuit-breaker-pattern">What is the Circuit Breaker Pattern?</h3>
<p>The <strong>Circuit Breaker</strong> is a resilience design pattern used in distributed systems to detect failures in remote services (e.g., APIs, databases) and prevent cascading failures by &quot;breaking&quot; the circuit—temporarily halting calls to the failing dependency. Inspired by electrical circuit breakers that trip to protect wiring from overloads, it allows a service to degrade gracefully instead of amplifying issues.</p>
<p>It's particularly valuable in microservices architectures, where one faulty component can domino-effect across the system. The pattern promotes fault isolation, faster failure detection, and automatic recovery, aligning with SRE goals like error budgets and high availability. Popularized by Michael Nygard in <em>Release It!</em> (2007), it's now a staple in libraries like Netflix's Hystrix (Java) and .NET's Polly.</p>
<h4 id="how-does-it-work">How Does It Work?</h4>
<p>The circuit breaker acts as a proxy between your service (caller) and the dependency (callee), monitoring interactions and transitioning between three states based on failure thresholds. It doesn't <em>fix</em> the underlying issue but buys time for recovery while providing fallbacks (e.g., cached data or default responses).</p>
<p>Here's the state machine:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Description</th>
<th>Behavior</th>
<th>Transition Triggers</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Closed</strong></td>
<td>Normal operation: All calls are allowed through. Failures are tracked (e.g., error rate or consecutive failures).</td>
<td>Calls proceed; exceptions/failures are counted but don't block.</td>
<td>Failure threshold exceeded → Open (e.g., 5 failures in 10 calls).</td>
</tr>
<tr>
<td><strong>Open</strong></td>
<td>&quot;Tripped&quot;: Calls are blocked to prevent overload. A fallback is invoked immediately.</td>
<td>Direct calls are short-circuited; quick failure (e.g., &lt;1ms) with fallback logic. Timer starts for potential recovery.</td>
<td>Elapsed timeout (e.g., 30s) → Half-Open.</td>
</tr>
<tr>
<td><strong>Half-Open</strong></td>
<td>Probation: A limited number of test calls (e.g., 1-2) are allowed to probe recovery.</td>
<td>Most calls still fallback; probes go through. Success resets to Closed; failure reopens.</td>
<td>Success on probes → Closed; Failure → Open.</td>
</tr>
</tbody>
</table>
<p><strong>Workflow Example</strong>:</p>
<ol>
<li><strong>Closed State</strong>: Your .NET app calls a payment API. It succeeds 90% of the time, but tracks the 10% errors.</li>
<li><strong>Threshold Hit</strong>: After 5 consecutive 500 errors (configurable), it trips to Open.</li>
<li><strong>Open State</strong>: Next 10 calls to payment API instantly return a fallback (e.g., &quot;Payment pending—retry later&quot;) without hitting the API, reducing load.</li>
<li><strong>Timeout Expires</strong>: After 30s, switches to Half-Open.</li>
<li><strong>Half-Open Probe</strong>: Sends 1 test request. If it succeeds, circuit closes (resumes normal calls). If it fails, reopens for another 30s.</li>
</ol>
<p>This prevents the &quot;thundering herd&quot; from retries (as discussed earlier) by pausing traffic entirely during outages.</p>
<p><strong>Visual Representation</strong> (Textual State Diagram):</p>
<pre><code>[Closed] ──(Failures &gt; Threshold)──&gt; [Open] ──(Timeout Expires)──&gt; [Half-Open]
   ↑          (Successes OK)             ↑                    ↑
   └──────────(Probe Success)────────────┘                    └──────────(Probe Failure)───(Back to Open)
</code></pre>
<h4 id="benefits">Benefits</h4>
<ul>
<li><strong>Fault Isolation</strong>: Stops one bad service from tanking the whole system (e.g., e-commerce cart works even if inventory API is down).</li>
<li><strong>Improved Latency</strong>: Fails fast in Open state, avoiding timeouts/retries.</li>
<li><strong>Self-Healing</strong>: Automates recovery without manual intervention.</li>
<li><strong>Observability</strong>: Metrics on state changes/trips aid debugging (integrate with Prometheus or Azure Monitor).</li>
</ul>
<h4 id="potential-issues-and-mitigations">Potential Issues and Mitigations</h4>
<ul>
<li><strong>False Positives</strong>: Trips on transient blips (e.g., network jitter). <em>Mitigate</em>: Tune thresholds (e.g., error volume over sliding window) and pair with retries/timeouts.</li>
<li><strong>Stale Fallbacks</strong>: Over-reliance on degraded responses. <em>Mitigate</em>: Time-bound fallbacks and user notifications.</li>
<li><strong>Synchronized Trips</strong>: All instances trip simultaneously. <em>Mitigate</em>: Per-instance breakers or shared state (e.g., via Redis).</li>
<li><strong>Increased Complexity</strong>: Adds state management. <em>Mitigate</em>: Use battle-tested libs like Polly.</li>
</ul>
<h4 id="implementation-in.net">Implementation in .NET</h4>
<p>In ASP.NET Core, implement via <strong>Polly</strong> (NuGet: <code>Polly.Extensions.Http</code>). It's declarative and composable with retries/timeouts.</p>
<pre><code class="language-csharp">// Program.cs: Register resilient HttpClient
services.AddHttpClient&lt;IPaymentService, PaymentService&gt;(client =&gt;
{
    client.BaseAddress = new Uri(&quot;https://api.payment.com&quot;);
})
.AddPolicyHandler(Policy.Handle&lt;HttpRequestException&gt;()
    .OrResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)
    .CircuitBreakerAsync( // Core policy
        handleRedundancy: 6,  // Failure threshold: 6 failures
        samplingDuration: TimeSpan.FromSeconds(30),  // Sliding window
        minimumThroughput: 10,  // Min calls to evaluate
        durationOfBreak: TimeSpan.FromSeconds(30),  // Open state duration
        onBreak: (outcome, context) =&gt; 
        {
            // Log trip
            logger.LogWarning(&quot;Circuit breaker opened: {Exception}&quot;, outcome.Exception);
        },
        onReset: (context) =&gt; 
        {
            // Log recovery
            logger.LogInformation(&quot;Circuit breaker reset&quot;);
        },
        onHalfOpen: (context) =&gt; 
        {
            // Log probe
            logger.LogInformation(&quot;Circuit breaker half-open&quot;);
        }))
    .WrapAsync(Policy.TimeoutAsync(TimeSpan.FromSeconds(10)))  // Compose with timeout
    .WrapAsync(GetRetryPolicy()));  // And retries

// In PaymentService.cs
public class PaymentService : IPaymentService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger&lt;PaymentService&gt; _logger;

    public PaymentService(HttpClient httpClient, ILogger&lt;PaymentService&gt; logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public async Task&lt;ProcessPaymentResponse&gt; ProcessPaymentAsync(ProcessPaymentRequest request)
    {
        // Polly executes the policy-wrapped call
        var response = await _httpClient.PostAsJsonAsync(&quot;/process&quot;, request);
        if (response.IsSuccessStatusCode)
        {
            return await response.Content.ReadFromJsonAsync&lt;ProcessPaymentResponse&gt;();
        }
        // Fallback invoked automatically in Open state
        return new ProcessPaymentResponse { Status = &quot;Fallback: Payment queued offline&quot; };
    }
}
</code></pre>
<p>Test with tools like WireMock for simulated failures. In interviews, discuss metrics (e.g., breaker state as a health check) and when to use it (e.g., over bulkheads for high-fanout deps).</p>
<p>Nailed another resilience gem! This pairs with retries/timeouts for a full fault-tolerance stack. What's next—bulkheads, saga patterns, or something on .NET-specific like middleware ordering?</p>

    </div>
</body>
</html>"