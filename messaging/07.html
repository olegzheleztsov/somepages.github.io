"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to HTML</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css">
    <style>
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }
    </style>
</head>
<body>
    <div class="markdown-body">
        <h3 id="organizing-streams-in-microservices">Organizing Streams in Microservices</h3>
<p>Organizing streams (e.g., in Kafka, Kinesis, or Pulsar) is a critical architectural decision in event-driven microservices. It affects scalability, maintainability, discoverability, and operational overhead. The goal is to balance loose coupling (services unaware of each other) with manageability (easy to route, secure, and monitor events). Common strategies include <strong>one stream for all services</strong>, <strong>stream per service</strong>, and <strong>stream per event type</strong>. There's no one-size-fits-all—use domain-driven design (DDD) to align with bounded contexts (e.g., topics per &quot;user domain&quot; vs. &quot;order domain&quot;).</p>
<p>I'll break down each approach, with pros/cons, then a comparison table and best practices.</p>
<h4 id="one-stream-for-all-services">1. <strong>One Stream for All Services</strong></h4>
<ul>
<li><strong>Description</strong>: All events from every service go into a single (or few) streams/topics. Use message keys or headers for routing/filtering (e.g., prefix events with &quot;service:event-type&quot;).</li>
<li><strong>When to Use</strong>: Early-stage prototypes or low-volume systems where simplicity trumps scale.</li>
<li><strong>Pros</strong>: Minimal topics to manage; easy global monitoring (e.g., one dashboard for throughput).</li>
<li><strong>Cons</strong>: Security nightmare (broad access policies); hard to scale partitions independently; &quot;topic bloat&quot; as volume grows, leading to hotspots.</li>
</ul>
<h4 id="stream-per-service">2. <strong>Stream per Service</strong></h4>
<ul>
<li><strong>Description</strong>: Each microservice owns one or more dedicated streams for the events it produces (e.g., &quot;user-service-events&quot;). Consumers subscribe based on service boundaries.</li>
<li><strong>When to Use</strong>: When services are highly autonomous and events are service-specific (e.g., internal metrics).</li>
<li><strong>Pros</strong>: Clear ownership (service team manages its stream); easier access controls (RBAC per service); isolates failures.</li>
<li><strong>Cons</strong>: Proliferation of streams (dozens/hundreds in large systems); cross-service event discovery is tough; potential for redundant schemas.</li>
</ul>
<h4 id="stream-per-event-type">3. <strong>Stream per Event Type</strong></h4>
<ul>
<li><strong>Description</strong>: Streams organized by domain or event category (e.g., &quot;user-events&quot; for registrations/logins, &quot;order-events&quot; for placements/cancellations). Services produce to relevant streams; use event sourcing patterns for types like &quot;UserCreated&quot; vs. &quot;UserUpdated&quot;.</li>
<li><strong>When to Use</strong>: Mature systems with clear domains; ideal for CQRS (Command Query Responsibility Segregation) where events drive multiple projections.</li>
<li><strong>Pros</strong>: High discoverability (semantic naming); scalable partitioning per type; supports fan-out to multiple consumers without coupling.</li>
<li><strong>Cons</strong>: Requires upfront domain modeling; schema evolution across services; more topics than &quot;one stream&quot; but fewer than &quot;per service&quot;.</li>
</ul>
<h4 id="hybrids-and-best-practices">4. <strong>Hybrids and Best Practices</strong></h4>
<ul>
<li><strong>Hybrid Approaches</strong>: Combine them—e.g., one stream per bounded context (grouping event types) with sub-partitions per service. Or use a &quot;backbone&quot; stream for core events, with service-specific side streams.</li>
<li><strong>General Guidelines</strong>:
<ul>
<li><strong>Naming</strong>: Consistent conventions (e.g., &quot;<domain>-<event-type>-v1&quot; for versioning).</li>
<li><strong>Governance</strong>: Central registry (e.g., Confluent Schema Registry) for schemas; automate topic creation via IaC (Terraform).</li>
<li><strong>Scaling</strong>: Start with 1-3 partitions per stream; monitor lag and rebalance as needed.</li>
<li><strong>Security</strong>: Topic-level ACLs; encrypt sensitive events.</li>
<li><strong>Migration</strong>: If starting with &quot;one stream,&quot; evolve by routing to new typed streams.</li>
<li><strong>Trade-Offs</strong>: Per-event-type wins for most (balances granularity); avoid &quot;one stream&quot; at scale to prevent the &quot;big ball of mud.&quot;</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Pros</th>
<th>Cons</th>
<th>Best For</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>One Stream (All Services)</strong></td>
<td>Simple ops; unified view</td>
<td>Poor isolation; scaling bottlenecks</td>
<td>Prototypes, small teams</td>
</tr>
<tr>
<td><strong>Stream per Service</strong></td>
<td>Ownership; failure isolation</td>
<td>Topic explosion; discovery issues</td>
<td>Autonomous, siloed services</td>
</tr>
<tr>
<td><strong>Stream per Event Type</strong></td>
<td>Semantic; flexible consumption</td>
<td>Domain modeling overhead</td>
<td>Domain-aligned, scalable systems</td>
</tr>
</tbody>
</table>
<p>In a tech lead interview, I'd say: &quot;I'd default to per-event-type using DDD bounded contexts—it promotes evolvability without over-fragmentation. For a new e-commerce app, I'd have 'order-events' for all order-related types, produced by multiple services.&quot; How does this fit your system design prep? Next topic?</p>

    </div>
</body>
</html>"