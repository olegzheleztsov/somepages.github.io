"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to HTML</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css">
    <style>
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }
    </style>
</head>
<body>
    <div class="markdown-body">
        <h3 id="what-are-docker-networks">What Are Docker Networks?</h3>
<p><strong>Docker networks</strong> are a mechanism for enabling communication between containers, the host machine, and external systems. They provide isolated, virtual networking environments where containers can discover and interact with each other using IP addresses, DNS names, or service names—without exposing ports unnecessarily. By default, Docker uses a <strong>bridge network</strong> (docker0) for single-host setups, but you can create custom networks for better isolation and flexibility.</p>
<p>Networks abstract away low-level networking (e.g., IPs, routing), allowing focus on app logic. Commands like <code>docker network create</code>, <code>docker network ls</code>, and <code>docker network inspect</code> manage them.</p>
<h4 id="key-network-types">Key Network Types</h4>
<p>Docker supports several drivers, each suited to scenarios:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
<th>When to Use</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bridge</strong> (Default)</td>
<td>Internal network for containers on the same host; uses NAT for external access. Containers get private IPs (e.g., 172.17.0.x).</td>
<td>Local dev/testing of multi-container .NET apps (e.g., API + DB). Simple, isolated from host.</td>
</tr>
<tr>
<td><strong>Host</strong></td>
<td>Container shares the host's network stack—no isolation (uses host's IP/ports).</td>
<td>High-perf needs where isolation isn't required (e.g., monitoring tools). Avoid for security-sensitive .NET services.</td>
</tr>
<tr>
<td><strong>Overlay</strong></td>
<td>Multi-host network for Docker Swarm/Kubernetes; creates a virtual network across nodes with encryption.</td>
<td>Distributed .NET microservices in production (e.g., Swarm cluster for API scaling). Enables service mesh-like discovery.</td>
</tr>
<tr>
<td><strong>Macvlan</strong></td>
<td>Assigns MAC addresses to containers, making them appear as physical devices on the network.</td>
<td>Integrating containers with legacy networks (e.g., .NET app mimicking a VM on a corp LAN).</td>
</tr>
<tr>
<td><strong>None</strong></td>
<td>Disables networking entirely—no IP or connectivity.</td>
<td>Air-gapped or isolated batch jobs (e.g., offline .NET data processor).</td>
</tr>
</tbody>
</table>
<p>Create/connect: <code>docker network create mynet --driver bridge</code>; <code>docker run --network mynet myapp</code>.</p>
<h3 id="use-cases-for-docker-networks">Use Cases for Docker Networks</h3>
<p>Networks solve connectivity challenges in containerized apps, especially for .NET ecosystems with services like APIs, queues, and DBs.</p>
<ol>
<li><p><strong>Multi-Container Communication</strong>: Link services without port mapping—e.g., a .NET Web API container pings a Redis container by name (<code>redis:6379</code>) on a custom bridge network. Use: Docker Compose stacks for full-stack .NET apps (frontend + backend + cache).</p>
</li>
<li><p><strong>Isolation &amp; Security</strong>: Segment traffic—e.g., dev/prod networks prevent cross-env leaks. Use: Compliance-heavy .NET finance apps, where internal services stay off the public bridge.</p>
</li>
<li><p><strong>Service Discovery</strong>: Auto-resolve names via built-in DNS. Use: Scaling .NET microservices; containers join an overlay network to dynamically find peers (e.g., via Consul integration).</p>
</li>
<li><p><strong>External Access Control</strong>: Expose only needed ports or use ingress. Use: Load-balanced .NET APIs—attach to bridge for localhost testing, overlay for cloud scaling.</p>
</li>
<li><p><strong>Hybrid Environments</strong>: Bridge for local, overlay for clusters. Use: CI/CD pipelines deploying .NET to AKS (Azure Kubernetes Service), where networks handle pod-to-pod routing.</p>
</li>
</ol>
<p><strong>Pro Tip for Your Interview</strong>: &quot;For a .NET e-comm app, I'd use a user-defined bridge network in Compose to let the API securely query Postgres without exposing DB ports—scales easily to overlay in Swarm.&quot; Demonstrates practical DevOps.</p>
<p>Next—maybe Docker Compose or Swarm?</p>

    </div>
</body>
</html>"