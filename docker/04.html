"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to HTML</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css">
    <style>
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }
    </style>
</head>
<body>
    <div class="markdown-body">
        <h3 id="speeding-up-the-docker-build-process">Speeding Up the Docker Build Process</h3>
<p>Building Docker images for .NET apps (e.g., ASP.NET Core) can be time-consuming due to layers like <code>dotnet restore</code> and <code>dotnet publish</code>. Optimization focuses on caching, minimizing layers, and parallelism—potentially cutting build times from 5-10 minutes to under 2. Here's how, step by step.</p>
<h4 id="leverage-layer-caching">1. <strong>Leverage Layer Caching</strong></h4>
<p>Docker caches unchanged layers, so order instructions to maximize hits.</p>
<ul>
<li><strong>Tip</strong>: Put stable steps first (e.g., <code>COPY *.csproj</code> then <code>RUN dotnet restore</code>), then volatile ones (e.g., <code>COPY . .</code> last).</li>
<li><strong>.NET Example Update to Dockerfile</strong>:
<pre><code>FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
# Copy csproj first for caching restore
COPY [&quot;MyApi.csproj&quot;, &quot;./&quot;]
RUN dotnet restore &quot;MyApi.csproj&quot;  # Cached if deps unchanged
COPY . .  # Only re-runs if source changes
RUN dotnet build &quot;MyApi.csproj&quot; -c Release -o /app/build
# ... rest as before
</code></pre>
</li>
<li><strong>Impact</strong>: 50-70% faster on repeated builds.</li>
</ul>
<h4 id="use-multi-stage-builds">2. <strong>Use Multi-Stage Builds</strong></h4>
<p>Separate build and runtime stages to discard dev tools early.</p>
<ul>
<li>Already in our example—keeps final image lean (~100 MB vs. 1 GB).</li>
<li><strong>Pro</strong>: Smaller images build/deploy faster; use <code>--target=build</code> for quick dev tests.</li>
</ul>
<h4 id="parallelize-and-minimize-steps">3. <strong>Parallelize and Minimize Steps</strong></h4>
<ul>
<li><strong>Combine RUNs</strong>: Chain commands (e.g., <code>RUN dotnet restore &amp;&amp; dotnet build</code>) to reduce layers.</li>
<li><strong>.dockerignore</strong>: Exclude unnecessary files (e.g., <code>bin/</code>, <code>obj/</code>, <code>*.md</code>)—like <code>.gitignore</code> for context.
<pre><code># .dockerignore
**/bin
**/obj
*.user
</code></pre>
</li>
<li><strong>BuildKit</strong>: Enable with <code>DOCKER_BUILDKIT=1 docker build ...</code> for parallel layer execution and better caching.</li>
</ul>
<h4 id="optimize.net-specific-steps">4. <strong>Optimize .NET-Specific Steps</strong></h4>
<ul>
<li><strong>Global.json</strong>: Pin SDK version for consistent, faster resolves.
<pre><code>{
  &quot;sdk&quot;: { &quot;version&quot;: &quot;8.0.100&quot; }
}
</code></pre>
</li>
</ul>
<pre><code>- **Restore with No-Cache**: In CI, use `--no-cache` sparingly; locally, clear with `dotnet nuget locals all --clear` if deps bloat.
- **Publish Flags**: Add `-r linux-x64` for self-contained, but skip if using base images.
- **NuGet Config**: Use private feeds with credentials in build args to avoid auth delays.

#### 5. **CI/CD and Tooling Integrations**
- **Buildx**: For multi-arch builds: `docker buildx build --platform linux/amd64,linux/arm64 -t myapp . --push`.
- **Pipeline Caching**: In Azure DevOps/GitHub Actions, cache NuGet (`actions/cache@4` with key on `global-packages`).
- **Remote Builders**: Use Buildx with cloud builders (e.g., GitHub Actions runners) for faster hardware.

| Optimization | Time Savings | When to Use |
|--------------|--------------|-------------|
| Layer Ordering | 40-60% | Every build |
| .dockerignore | 10-20% | Large repos |
| BuildKit | 20-30% | Complex multi-stage |
| CI Caching | 50-80% | Team/CI runs |

**Pro Tip for Your Interview**: &quot;In a .NET CI pipeline, I'd layer NuGet caching with BuildKit, reducing builds from 4 min to 45s—key for frequent deploys in microservices.&quot; Test locally with `time docker build` to measure wins.

If this is about .NET `dotnet build` (not Docker), lmk—tips include `/p:RestorePackagesWithLockFile=true` and parallel tasks (`/m`). Next?
</code></pre>

    </div>
</body>
</html>"