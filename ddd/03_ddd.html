"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to HTML</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css">
    <style>
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }
    </style>
</head>
<body>
    <div class="markdown-body">
        <h3 id="ddd-building-blocks-enumeration-and-descriptions">DDD Building Blocks: Enumeration and Descriptions</h3>
<p>In Domain-Driven Design (DDD), building blocks are the foundational patterns and concepts that help model complex domains effectively. They are divided into <strong>strategic</strong> (high-level, for overall structure) and <strong>tactical</strong> (low-level, for implementation) patterns. These ensure the code reflects the business domain, promotes maintainability, and aligns with the ubiquitous language. Below, I'll enumerate the key ones with descriptions, examples, and their roles—drawn from Eric Evans' foundational work and modern adaptations.</p>
<h4 id="strategic-building-blocks">Strategic Building Blocks</h4>
<p>These guide the big-picture architecture, especially in large systems.</p>
<ol>
<li><p><strong>Ubiquitous Language</strong></p>
<ul>
<li><strong>Description</strong>: A shared, rigorous vocabulary used consistently by domain experts, developers, and in the code itself. It eliminates ambiguity and ensures everyone speaks the same &quot;language&quot; about the domain.</li>
<li><strong>Role/Use</strong>: Forms the foundation—e.g., define &quot;Invoice&quot; precisely in docs, conversations, and class names.</li>
<li><strong>Example</strong>: In a banking app, &quot;Overdraft&quot; means a specific fee calculation, not a casual term.</li>
</ul>
</li>
<li><p><strong>Bounded Context</strong></p>
<ul>
<li><strong>Description</strong>: A boundary within which a domain model is defined and consistent; outside it, the model (and language) may differ. It encapsulates a subdomain to manage complexity.</li>
<li><strong>Role/Use</strong>: Enables modular design, like microservices; use context mapping for integration.</li>
<li><strong>Example</strong>: &quot;Order&quot; in Sales Context vs. &quot;Shipment&quot; in Logistics Context.</li>
</ul>
</li>
<li><p><strong>Subdomain</strong></p>
<ul>
<li><strong>Description</strong>: A partition of the overall domain into core (business differentiator), supporting (essential but generic), and generic (off-the-shelf) areas.</li>
<li><strong>Role/Use</strong>: Prioritizes focus—invest heavily in core subdomains.</li>
<li><strong>Example</strong>: In e-commerce, core = Recommendation Engine; supporting = User Authentication.</li>
</ul>
</li>
<li><p><strong>Context Mapping</strong></p>
<ul>
<li><strong>Description</strong>: Patterns for how bounded contexts interact (e.g., Shared Kernel for collaboration, Anti-Corruption Layer for protection).</li>
<li><strong>Role/Use</strong>: Handles integration without coupling—e.g., upstream/downstream relationships.</li>
<li><strong>Example</strong>: Translate &quot;Customer ID&quot; from CRM Context to &quot;Account Reference&quot; in Billing.</li>
</ul>
</li>
</ol>
<h4 id="tactical-building-blocks">Tactical Building Blocks</h4>
<p>These are implementation-focused, used within a bounded context to build the model.</p>
<table>
<thead>
<tr>
<th>Building Block</th>
<th>Description</th>
<th>Role/Use</th>
<th>Example in E-Commerce</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Entity</strong></td>
<td>An object defined by its identity (ID) and thread of continuity over time; mutable with lifecycle.</td>
<td>Represents things that change but must be tracked uniquely.</td>
<td>Customer (ID: 123, updates address over years).</td>
</tr>
<tr>
<td><strong>Value Object</strong></td>
<td>An immutable object defined solely by its attributes; no identity, interchangeable if values match.</td>
<td>Simplifies equality/comparison; avoids identity overhead for composites.</td>
<td>Money (Amount + Currency; $10 USD == another $10 USD).</td>
</tr>
<tr>
<td><strong>Aggregate</strong></td>
<td>A cluster of entities/value objects treated as a single unit, with a root entity guarding consistency.</td>
<td>Enforces invariants (business rules) at the boundary; optimizes transactions.</td>
<td>Order (root) + LineItems (total recalculated on changes).</td>
</tr>
<tr>
<td><strong>Domain Event</strong></td>
<td>An immutable object capturing a significant business occurrence; decouples publishers from subscribers.</td>
<td>Enables eventual consistency and reactive systems (e.g., via event sourcing).</td>
<td>OrderShipped (triggers email and inventory update).</td>
</tr>
<tr>
<td><strong>Repository</strong></td>
<td>An abstraction (interface) for accessing aggregates; hides persistence details like databases.</td>
<td>Provides collection-like access (e.g., findById, add/remove); test-friendly.</td>
<td>OrderRepository (save(Order), findByStatus(&quot;Pending&quot;)).</td>
</tr>
<tr>
<td><strong>Domain Service</strong></td>
<td>Stateless operations that don't fit neatly into an entity/value object; encapsulates domain logic.</td>
<td>Handles cross-aggregate or external collaborations without bloating models.</td>
<td>PaymentService (validate + process across Order and Account).</td>
</tr>
<tr>
<td><strong>Factory</strong></td>
<td>A method/class for creating complex objects/aggregates, hiding construction complexity.</td>
<td>Ensures valid instances; useful for entities with many dependencies.</td>
<td>OrderFactory (createFromCart, ensuring invariants).</td>
</tr>
<tr>
<td><strong>Module</strong> (or Package)</td>
<td>A grouping mechanism for code organization within a bounded context; enforces boundaries.</td>
<td>Improves cohesion and hides internals; aligns with layers (domain, application).</td>
<td>Domain module containing all e-commerce entities/services.</td>
</tr>
</tbody>
</table>
<p>These blocks work together: e.g., Entities form Aggregates, accessed via Repositories, triggered by Domain Events. In practice, start with strategic ones for architecture, then tactical for coding. As a tech lead, I'd enforce them via code reviews to avoid anemic models.</p>
<p>Great depth-builder for DDD interviews—how does this fit your prep, or next up?</p>

    </div>
</body>
</html>"